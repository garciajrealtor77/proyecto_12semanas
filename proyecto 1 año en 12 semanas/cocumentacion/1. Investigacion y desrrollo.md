Sí, conozco el libro "El Año de 12 Semanas" (The 12 Week Year) de Brian P. Moran y Michael Lennington.

Es un libro muy popular en el ámbito de la productividad y el logro de metas. La idea central es que en lugar de planificar el año completo con metas a largo plazo, se divide el año en ciclos de 12 semanas, tratando cada ciclo como si fuera un "mini-año". Esto ayuda a mantener el enfoque, la urgencia y la responsabilidad, ya que las metas son más cercanas y tangibles.

El libro propone un sistema para establecer metas, planificar acciones, medir el progreso y mantener la disciplina para alcanzar resultados significativos en periodos cortos. Es una metodología que muchas personas y empresas han adoptado para mejorar su desempeño.

¿Te gustaría saber algo más específico sobre él?






Asume el rol de un programador especialista en HTML5, CSS, JSON y JAVASCRIPT nativo. Si tuvieses que hacer una aplicación web para que funcione de forma local en un teléfono Android con las siguientes características: Sistema operativo 2.0.105.0VNNMIXM con la versión 15 AP3A.240617.008 con almacenamiento de + de 512 y mas de 16GB de RAM y que cuente con las aplicaciones Simple HTTP Server. La aplicación que se desea desarrollar esta enfocada al año de 12 semanas. Preséntame una propuesta. Que contenga botones, CRUD, analiza si puede tener una estructura MVC, si tecnológicamente es posible.



¡Entendido! Asumo el rol de programador especialista en HTML5, CSS, JSON y JavaScript nativo. Dada la descripción de un dispositivo Android con las características especificadas (OS 2.0.105.0VNNMIXM, versión 15 AP3A.240617.008, +512GB de almacenamiento, +16GB de RAM y la presencia de Simple HTTP Server), y el enfoque en la metodología del "Año de 12 Semanas", puedo presentarte una propuesta sólida para una aplicación web local.

Propuesta de Aplicación Web Local: "Mi Año de 12 Semanas"
Considerando las especificaciones del dispositivo y la necesidad de que la aplicación funcione de forma local a través de Simple HTTP Server, la propuesta se centra en una arquitectura robusta y eficiente, utilizando tecnologías web estándar.

1. Concepto y Alcance
La aplicación permitirá al usuario gestionar sus ciclos del "Año de 12 Semanas". Esto incluye:

Definición de Visiones y Metas a Largo Plazo: Posibilidad de registrar la visión a largo plazo y las metas anuales que sustentan los ciclos de 12 semanas.

Gestión de Ciclos (12 Semanas): Creación, seguimiento y revisión de cada ciclo individual, incluyendo la definición de su fecha de inicio y fin.

Definición de Metas de 12 Semanas: Establecimiento de 3-5 metas clave para cada ciclo, con sus respectivos indicadores de éxito.

Planificación Semanal: Desglose de las metas de 12 semanas en tareas y actividades semanales.

Seguimiento y Evaluación Diaria/Semanal: Registro del progreso, puntuación de cumplimiento y notas.

Reportes Básicos: Visualización del progreso general de un ciclo y de las metas individuales.

2. Estructura Tecnológica
Dado que la aplicación debe funcionar de forma local en el dispositivo Android a través de Simple HTTP Server, la pila tecnológica será puramente front-end, con almacenamiento de datos en el propio navegador.

HTML5: Para la estructura y semántica del contenido. Se utilizará para crear las diferentes vistas de la aplicación (dashboard, creación de ciclo, gestión de metas, etc.).

CSS3 (Nativo): Para el diseño, la interfaz de usuario (UI) y la experiencia de usuario (UX). Se aplicarán técnicas de diseño responsivo (@media queries, Flexbox, Grid) para asegurar una buena visualización en pantallas de teléfonos móviles.

JavaScript (Nativo): Será el motor de la aplicación. Manejará toda la lógica de negocio, la interacción con el usuario (eventos de botones, formularios), la manipulación del DOM y la persistencia de datos.

JSON: Se utilizará como formato para el almacenamiento y la recuperación de datos. Todos los datos de la aplicación (ciclos, metas, tareas, progreso) se serializarán y deserializarán como objetos JSON.

localStorage / IndexedDB: Para la persistencia de datos en el dispositivo. Dada la gran capacidad de almacenamiento (+512GB), IndexedDB es la opción preferida por su capacidad para manejar grandes volúmenes de datos estructurados de manera asíncrona, lo que es ideal para un CRUD complejo. localStorage podría ser una opción más simple para datos más pequeños o configuración, pero para la gestión de múltiples ciclos y metas, IndexedDB es superior.

3. Funcionalidades Clave (Botones y CRUD)
La aplicación estará llena de interacciones basadas en botones y operaciones CRUD (Crear, Leer, Actualizar, Borrar).

Botones:

Navegación: Botones para moverse entre secciones (Inicio, Ciclos, Metas, Reportes).

Acciones:

"Nuevo Ciclo", "Nueva Meta", "Nueva Tarea".

"Guardar", "Editar", "Eliminar".

"Marcar como Completado".

"Puntuar Progreso".

"Exportar Datos" (posiblemente a un archivo JSON descargable).

CRUD:

C (Crear): Formularios para crear nuevos ciclos, metas de 12 semanas, tareas semanales.

R (Leer): Listados de ciclos activos/inactivos, detalles de metas, seguimiento del progreso.

U (Actualizar): Edición de información de ciclos, metas, tareas, actualización de estado y progreso.

D (Borrar): Eliminación de ciclos, metas o tareas (con confirmación para evitar borrados accidentales).

4. Análisis de Arquitectura MVC (Modelo-Vista-Controlador)
Sí, es absolutamente posible implementar una estructura MVC (o una variante MVVM/MVP adaptada al cliente) utilizando JavaScript nativo en esta aplicación web local. De hecho, es altamente recomendable para mantener el código organizado, mantenible y escalable.

Modelo (Model): Representará los datos y la lógica de negocio.

Clases o funciones constructoras de JavaScript que encapsulan la estructura de datos (e.g., Ciclo, Meta, Tarea).

Métodos para interactuar con IndexedDB (guardar, cargar, actualizar, eliminar).

Lógica para calcular el progreso, la puntuación de metas, etc.

Vista (View): La interfaz de usuario que el usuario ve e interactúa.

Generada dinámicamente con JavaScript y HTML/CSS.

Actualizada en respuesta a cambios en el Modelo.

Manejará la presentación de los datos.

Controlador (Controller): Actuará como el intermediario entre el Modelo y la Vista.

Manejará los eventos del usuario (clics en botones, envíos de formularios).

Actualizará el Modelo en respuesta a las acciones del usuario.

Notificará a la Vista para que se actualice cuando el Modelo cambie.

Ventajas de MVC en este contexto:

Separación de Preocupaciones: Facilita la comprensión y el mantenimiento del código al dividirlo en componentes lógicos.

Reusabilidad: Los componentes del Modelo y, en cierta medida, de la Vista, pueden ser reutilizados.

Facilidad de Pruebas: Cada componente puede ser probado de forma más aislada.

Escalabilidad: A medida que la aplicación crezca, la estructura MVC ayudará a gestionar la complejidad.

5. Viabilidad Tecnológica
Sí, tecnológicamente es 100% posible y viable.

Capacidad del Dispositivo: Las especificaciones de hardware (más de 512GB de almacenamiento y más de 16GB de RAM) son sobradas para ejecutar una aplicación web local basada en HTML, CSS y JavaScript nativo, incluso con datos en IndexedDB.

Sistema Operativo Android: Android soporta perfectamente la ejecución de navegadores web modernos (como Chrome, que subyace en la mayoría de los WebView) que tienen soporte completo para HTML5, CSS3, JavaScript ES6+ y APIs como IndexedDB.

Simple HTTP Server: Al estar disponible, esto permite que la aplicación web se sirva como cualquier sitio web, pero de forma local, accesible a través del navegador web del teléfono. El usuario simplemente navegará a la dirección http://localhost:port (o la IP local del servidor) para acceder a la aplicación.

JavaScript Nativo y APIs Web: El uso de JavaScript nativo y APIs estándar como IndexedDB asegura que la aplicación será ligera, rápida y no dependerá de frameworks o librerías externas que puedan introducir sobrecarga o problemas de compatibilidad en un entorno offline/local.

6. Desafíos a Considerar (y Soluciones)
Sincronización de Datos: Si en algún momento se deseara sincronizar datos con la nube o entre dispositivos, habría que implementar una capa adicional de lógica de sincronización (lo cual iría más allá del alcance puramente local, pero es un punto a tener en cuenta para futuras mejoras).

Actualizaciones de la Aplicación: Las actualizaciones implicarían reemplazar los archivos HTML, CSS y JavaScript en el directorio donde Simple HTTP Server los está sirviendo.

Experiencia de Usuario: Asegurar una UX fluida y responsiva en un entorno móvil requerirá un diseño CSS cuidadoso y optimizaciones en el manejo del DOM con JavaScript para evitar cuellos de botella de rendimiento.

Seguridad: Al ser una aplicación local, las preocupaciones de seguridad son menores que en una aplicación conectada a internet, pero aún así se deben seguir buenas prácticas de codificación (ej., sanitización de entradas si hay campos de texto complejos, aunque en este caso la principal amenaza sería el acceso físico al dispositivo).

En resumen, esta propuesta ofrece una solución robusta y completamente viable para la aplicación "Mi Año de 12 Semanas" en el entorno especificado. La utilización de tecnologías web estándar garantiza un rendimiento óptimo y una gran flexibilidad para futuras mejoras.

¿Hay algún aspecto en particular que te gustaría que profundizara, o alguna funcionalidad específica que quisieras añadir a la propuesta?






La sincronización con la nube, aunque seria genial, tal vez en este momento pueda ser una complicación, evalúa si es factible, los recursos en la nube con los que cuento son, drive y notion, únicamente, si no hay impedimentos tecnológicos, hagámoslo, si hay imposibilidad porque tenemos dependencia de terceros vamos a descartarlo. La otra inquietud que tengo es: seria posible guardar los datos en la carpeta data y desde allí manejar toda la base de datos es decir, que los datos se manejen a un nivel de carpetas hermano, sin que se deba guardar directamente al dispositivo, sino en esa carpeta data o alguna con otro nombre, pero a ese mismo nivel, lo cual, si se desea mover todo el proyecto en conjunto desde la carpeta central a otro dispositivo se pueda, es decir, que el proyecto sea portable y se mantengan intactos los datos de la base de datos. Hazme un informe al respecto. Esoero tu respuesta



¡Excelente! Abordemos tus inquietudes sobre la sincronización con la nube y la portabilidad de los datos, manteniendo nuestro enfoque en una aplicación web local robusta.

Informe: Sincronización en la Nube y Portabilidad de Datos
1. Sincronización con la Nube (Google Drive y Notion)
Vamos a evaluar la factibilidad de sincronización con Google Drive y Notion directamente desde nuestra aplicación web local, considerando la dependencia de terceros.

Análisis de Factibilidad:

Google Drive:

Imposibilidad Directa sin Dependencias: Para interactuar programáticamente con Google Drive (subir, descargar o sincronizar archivos), nuestra aplicación web local necesitaría usar la Google Drive API. Acceder a esta API requiere:

Registro de la aplicación en Google Cloud Console: Obtener credenciales de API (ID de cliente, secreto de cliente).

Autenticación OAuth 2.0: El usuario final tendría que iniciar sesión en su cuenta de Google y otorgar permisos a nuestra aplicación para acceder a su Drive. Esto implica redirecciones a Google, manejo de tokens de acceso y refresco, lo cual ya es una dependencia significativa de terceros.

Conexión a Internet: Para que la API funcione, el dispositivo debe tener conexión a internet.

Conclusión: La sincronización directa con Google Drive no es factible sin una dependencia fuerte de terceros (Google API y su infraestructura de autenticación). Esto añade una capa de complejidad considerable y requeriría que la aplicación "saliera" de su entorno puramente local para interactuar con servicios externos, algo que deseas evitar si implica dependencias complejas.

Notion:

Imposibilidad Directa sin Dependencias: Similar a Google Drive, Notion ofrece una Notion API. Para usarla, nuestra aplicación necesitaría:

Obtener un token de integración: Esto se configura manualmente en Notion.

Enviar peticiones HTTP: Interactuar con la API de Notion implica enviar solicitudes HTTP a sus servidores para crear/actualizar páginas, bases de datos, etc.

Conexión a Internet: Indispensable para comunicarse con la API de Notion.

Conclusión: La sincronización directa con Notion tampoco es factible sin una dependencia de terceros (Notion API). Además, Notion está más orientado a documentos y bases de datos estructuradas dentro de su propio ecosistema, lo que podría no ser la forma más natural de almacenar los datos de nuestra aplicación si pensamos en una sincronización bidireccional simple.

Recomendación sobre Sincronización en la Nube:

Dada tu preferencia por evitar dependencias de terceros que compliquen el proyecto o requieran autenticación externa, descartamos la sincronización directa con Google Drive y Notion para esta fase de la aplicación. Mantener la aplicación puramente local y autónoma es la prioridad.

Sin embargo, como una alternativa manual y sin dependencias programáticas, se podría implementar una funcionalidad de "Exportar/Importar Datos". La aplicación podría permitir al usuario:

Exportar datos: Generar un archivo JSON con todos los datos del usuario (ciclos, metas, tareas) que el usuario pueda guardar manualmente en su Google Drive, enviarse por correo, etc.

Importar datos: Permitir al usuario seleccionar un archivo JSON previamente exportado para cargar los datos en la aplicación.

Esta opción ofrece una forma de "backup" y "restauración" que el usuario gestiona manualmente, sin que la aplicación tenga que interactuar directamente con los servicios de nube.

2. Portabilidad de Datos: Guardar en una Carpeta Hermano (data/)
Tu inquietud sobre la portabilidad de los datos al nivel de una carpeta hermano es muy pertinente para una aplicación web local.

Análisis de Factibilidad y Restricciones:

HTML5 / JavaScript en el Navegador: Por naturaleza, las aplicaciones web que corren en un navegador (o WebView, como en Android) están aisladas por motivos de seguridad (Same-Origin Policy y sandboxing). Esto significa que JavaScript ejecutándose en el navegador no tiene acceso directo y arbitrario al sistema de archivos local del dispositivo.

IndexedDB y localStorage: Los datos guardados con IndexedDB y localStorage se almacenan en el perfil del navegador o en el espacio de almacenamiento asignado a la aplicación WebView en el dispositivo. Este almacenamiento es interno y no se encuentra en una carpeta accesible directamente por el usuario al nivel de "hermano" del proyecto (data/ o similar).

No son archivos que se puedan mover fácilmente: Los datos de IndexedDB son una base de datos interna, no un archivo JSON simple en una carpeta. localStorage guarda pares clave-valor directamente en el navegador.

La Carpeta data/ y Simple HTTP Server:

El Simple HTTP Server lo que hace es servir archivos desde un directorio específico (el directorio raíz del proyecto). Podrías tener una carpeta data/ dentro de tu proyecto donde coloques imágenes, videos, o cualquier otro archivo estático que tu aplicación web necesite leer.

El problema: JavaScript en el cliente no puede escribir archivos en esa carpeta data/ (o en cualquier otra carpeta del sistema de archivos) para persistir la base de datos de la aplicación. Solo puede leer archivos existentes que el servidor HTTP le proporciona (como el propio HTML, CSS, JS).

Conclusión sobre Portabilidad Directa de la Base de Datos:

No es posible guardar la base de datos de IndexedDB (o localStorage) directamente en una carpeta (data/ o cualquier otra) al mismo nivel del proyecto de forma que sea simplemente "movible" junto con el proyecto. La persistencia de datos en el navegador es interna a la aplicación y al navegador.

Solución para la Portabilidad de Datos (Mejor Enfoque):

La mejor manera de lograr la portabilidad que buscas es a través de una combinación de lo que mencionamos para la nube: funcionalidad de Exportar/Importar datos.

Exportar Datos (Guardar como Archivo Descargable):

La aplicación web puede tomar todos los datos almacenados en IndexedDB.

Serializarlos en un único archivo JSON.

Ofrecer este archivo JSON como una descarga al usuario (utilizando JavaScript y el atributo download en un elemento <a>).

El usuario puede entonces elegir dónde guardar este archivo JSON en su dispositivo (ej., en su carpeta de Descargas, o moverlo manualmente a una carpeta data/ si así lo prefiere, pero esto lo haría el usuario, no la aplicación automáticamente).

Importar Datos (Cargar un Archivo Existente):

La aplicación presentaría un botón "Importar Datos" que abriría un selector de archivos (<input type="file">).

El usuario seleccionaría el archivo JSON que previamente exportó.

La aplicación leería este archivo y cargaría los datos en IndexedDB, sobrescribiendo o fusionando los datos existentes según la lógica que definamos.

Ventajas de este enfoque:

Total Portabilidad del "Estado": Al exportar los datos como JSON, puedes mover ese archivo a cualquier otro dispositivo.

Simple: No requiere APIs complejas ni acceso al sistema de archivos del SO desde el navegador.

Control del Usuario: El usuario tiene control total sobre dónde se guardan sus backups y cuándo los importa.

Consideración para la Estructura de Carpetas:

Tu proyecto web tendría una estructura como esta:

mi-año-12-semanas/
├── index.html
├── css/
│   └── style.css
├── js/
│   └── app.js
│   └── model.js
│   └── view.js
│   └── controller.js
└── assets/ (para imágenes, iconos, etc.)
    └── logo.png
    └── ...
Los datos de IndexedDB estarían guardados internamente en el navegador del teléfono, separados de estos archivos del proyecto. Para "mover todo el proyecto en conjunto", simplemente copiarías la carpeta mi-año-12-semanas/ completa. Si quieres mover los datos también, llevarías el archivo JSON exportado por separado y lo importarías en el nuevo dispositivo.

En resumen, la sincronización directa con Drive o Notion introduce dependencias de terceros que quieres evitar. La mejor aproximación es la exportación/importación manual de datos. Y la portabilidad de la base de datos se logra mediante esta misma mecánica de exportación/importación de archivos JSON, ya que la base de datos (IndexedDB) es interna del navegador y no se aloja en una carpeta del proyecto que puedas simplemente "copiar y pegar".

¿Te parece un enfoque adecuado esta estrategia de exportación/importación manual para la portabilidad y el backup de datos?







Perfecto, descartemos la sincronización con terceros en la nube y vamos adoptar la propuesta que haces. Procede a generar los archivos con el código completo en cada uno de los archivos, usa imágenes de la internet si los requieres. Crea el proyecto de forma tal que solo tenga que copiar y pegar el código en sus respectivos los archivos. Toma en cuenta la responsividad, para que se vea bien tanto en pcs y especialmente en teléfonos. Tienes luz verde para generar los archivos, no te limites, da lo mejor de ti y verifica que el todo funcione bien, por favor pon especial interés en eso, que todo este funcionando bien.


¡Absolutamente! Con la luz verde, vamos a crear el proyecto "Mi Año de 12 Semanas" con HTML5, CSS y JavaScript nativo, enfocado en la portabilidad y el funcionamiento local. Te proporcionaré el código completo para cada archivo, listo para copiar y pegar.

Proyecto: Mi Año de 12 Semanas (Aplicación Web Local)
Este proyecto estará estructurado para ser auto-contenido y portátil. Simplemente copia la carpeta principal a tu dispositivo Android, iníciala con Simple HTTP Server, y listo.

Estructura de Carpetas del Proyecto
Crea una carpeta principal llamada mi-ano-12-semanas. Dentro de ella, crea las siguientes subcarpetas y archivos:

mi-ano-12-semanas/
├── index.html
├── css/
│   └── style.css
├── js/
│   └── app.js
│   └── models.js
│   └── views.js
│   └── controllers.js
│   └── db.js  (Nuevo archivo para IndexedDB)
└── assets/
    └── icon_cycle.png   (Ejemplo de icono, puedes usar el tuyo)
    └── icon_goal.png
    └── icon_task.png
    └── logo.png
1. index.html (La Estructura Principal)
Este archivo define la estructura de la aplicación y enlaza los estilos y scripts.

HTML

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Año de 12 Semanas</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" href="assets/logo.png" type="image/png">
</head>
<body>
    <header class="app-header">
        <img src="assets/logo.png" alt="Logo Mi Año de 12 Semanas" class="app-logo">
        <h1>Mi Año de 12 Semanas</h1>
        <nav class="main-nav">
            <button id="nav-home" class="active">Inicio</button>
            <button id="nav-cycles">Ciclos</button>
            <button id="nav-goals">Metas</button>
            <button id="nav-export-import">Exportar/Importar</button>
        </nav>
    </header>

    <main class="app-container">
        <section id="dashboard-view" class="view active">
            <h2>Dashboard</h2>
            <div id="active-cycle-summary" class="summary-card">
                <h3>Ciclo Activo Actual</h3>
                <p id="current-cycle-name">No hay ciclo activo.</p>
                <p id="current-cycle-dates"></p>
                <p id="current-cycle-progress">Progreso General: 0%</p>
                <div class="progress-bar-container">
                    <div id="current-cycle-progress-bar" class="progress-bar" style="width: 0%;"></div>
                </div>
                <button id="view-active-cycle-details" class="btn btn-primary" style="display: none;">Ver Detalles</button>
            </div>

            <div class="summary-card">
                <h3>Próximas Metas / Tareas</h3>
                <ul id="upcoming-items-list" class="simple-list">
                    <li>No hay tareas próximas.</li>
                </ul>
            </div>
        </section>

        <section id="cycles-view" class="view hidden">
            <h2>Gestión de Ciclos</h2>
            <button id="add-cycle-btn" class="btn btn-primary">Nuevo Ciclo</button>
            <div id="cycle-form-container" class="form-container hidden">
                <h3><span id="cycle-form-title">Crear Nuevo Ciclo</span></h3>
                <form id="cycle-form">
                    <input type="hidden" id="cycle-id">
                    <label for="cycle-name">Nombre del Ciclo:</label>
                    <input type="text" id="cycle-name" required>
                    <label for="cycle-start-date">Fecha de Inicio:</label>
                    <input type="date" id="cycle-start-date" required>
                    <button type="submit" class="btn btn-success">Guardar Ciclo</button>
                    <button type="button" id="cancel-cycle-form-btn" class="btn btn-secondary">Cancelar</button>
                </form>
            </div>

            <h3>Ciclos Existentes</h3>
            <div id="cycles-list" class="card-list">
                <p class="no-items-message">No hay ciclos creados aún.</p>
            </div>
        </section>

        <section id="goals-view" class="view hidden">
            <h2>Gestión de Metas</h2>
            <select id="select-cycle-for-goals" class="form-control">
                <option value="">Selecciona un Ciclo</option>
            </select>
            <p id="no-cycle-selected-message" class="info-message">Por favor, selecciona un ciclo para ver y añadir metas.</p>

            <button id="add-goal-btn" class="btn btn-primary hidden">Nueva Meta</button>
            <div id="goal-form-container" class="form-container hidden">
                <h3><span id="goal-form-title">Crear Nueva Meta</span></h3>
                <form id="goal-form">
                    <input type="hidden" id="goal-id">
                    <input type="hidden" id="goal-cycle-id">
                    <label for="goal-name">Nombre de la Meta:</label>
                    <input type="text" id="goal-name" required>
                    <label for="goal-description">Descripción:</label>
                    <textarea id="goal-description"></textarea>
                    <label for="goal-target">Objetivo/Métrica:</label>
                    <input type="text" id="goal-target" required>
                    <button type="submit" class="btn btn-success">Guardar Meta</button>
                    <button type="button" id="cancel-goal-form-btn" class="btn btn-secondary">Cancelar</button>
                </form>
            </div>

            <h3>Metas del Ciclo <span id="current-cycle-goals-name"></span></h3>
            <div id="goals-list" class="card-list">
                <p class="no-items-message">No hay metas para este ciclo aún.</p>
            </div>
        </section>

        <section id="export-import-view" class="view hidden">
            <h2>Exportar / Importar Datos</h2>
            <div class="summary-card">
                <h3>Exportar Datos</h3>
                <p>Guarda todos tus ciclos, metas y tareas en un archivo JSON para hacer una copia de seguridad o transferirlos a otro dispositivo.</p>
                <button id="export-data-btn" class="btn btn-primary">Exportar Datos</button>
            </div>

            <div class="summary-card">
                <h3>Importar Datos</h3>
                <p>Carga un archivo JSON previamente exportado para restaurar tus datos. **¡Advertencia!** Esto sobrescribirá los datos existentes.</p>
                <input type="file" id="import-file-input" accept=".json" class="hidden">
                <button id="import-data-btn" class="btn btn-secondary">Seleccionar Archivo JSON</button>
                <button id="confirm-import-btn" class="btn btn-danger hidden">Confirmar Importación</button>
                <button id="cancel-import-btn" class="btn btn-secondary hidden">Cancelar</button>
                <p id="import-file-name" class="info-message"></p>
            </div>
        </section>

        <div id="task-modal" class="modal hidden">
            <div class="modal-content">
                <span class="close-button">&times;</span>
                <h3 id="task-modal-title">Gestión de Tareas</h3>
                <input type="hidden" id="modal-goal-id">
                <button id="add-task-btn" class="btn btn-primary">Nueva Tarea</button>
                <div id="task-form-container" class="form-container hidden">
                    <h4><span id="task-form-title">Crear Nueva Tarea</span></h4>
                    <form id="task-form">
                        <input type="hidden" id="task-id">
                        <label for="task-name">Descripción de la Tarea:</label>
                        <input type="text" id="task-name" required>
                        <label for="task-due-date">Fecha Límite (opcional):</label>
                        <input type="date" id="task-due-date">
                        <button type="submit" class="btn btn-success">Guardar Tarea</button>
                        <button type="button" id="cancel-task-form-btn" class="btn btn-secondary">Cancelar</button>
                    </form>
                </div>
                <h4>Tareas de la Meta</h4>
                <ul id="tasks-list" class="simple-list">
                    <p class="no-items-message">No hay tareas para esta meta aún.</p>
                </ul>
            </div>
        </div>

        <div id="confirm-modal" class="modal hidden">
            <div class="modal-content">
                <span class="close-button">&times;</span>
                <h3>Confirmar Eliminación</h3>
                <p id="confirm-modal-message">¿Estás seguro de que quieres eliminar este elemento?</p>
                <button id="confirm-delete-btn" class="btn btn-danger">Eliminar</button>
                <button id="cancel-delete-btn" class="btn btn-secondary">Cancelar</button>
            </div>
        </div>

    </main>

    <script src="js/db.js"></script>
    <script src="js/models.js"></script>
    <script src="js/views.js"></script>
    <script src="js/controllers.js"></script>
    <script src="js/app.js"></script>
</body>
</html>
2. css/style.css (Estilos Responsivos)
Este archivo contendrá todo el CSS para la apariencia de la aplicación, con un enfoque en la responsividad.

CSS

/* Variables CSS */
:root {
    --primary-color: #4CAF50; /* Green */
    --secondary-color: #607D8B; /* Blue Grey */
    --accent-color: #FFC107; /* Amber */
    --danger-color: #F44336; /* Red */
    --success-color: #8BC34A; /* Light Green */
    --text-color: #333;
    --background-color: #f0f2f5;
    --card-background: #ffffff;
    --border-color: #ddd;
    --shadow: 0 2px 4px rgba(0,0,0,0.1);
    --border-radius: 8px;
    --padding-base: 16px;
}

/* Base Styles */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

body {
    background-color: var(--background-color);
    color: var(--text-color);
    line-height: 1.6;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
}

.app-header {
    background-color: var(--primary-color);
    color: white;
    padding: var(--padding-base);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    box-shadow: var(--shadow);
    text-align: center;
    flex-shrink: 0; /* Prevents header from shrinking */
}

.app-logo {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-color: white;
    padding: 5px;
}

.app-header h1 {
    font-size: 1.8em;
    margin: 0;
}

.main-nav {
    display: flex;
    flex-wrap: wrap; /* Allow wrapping on small screens */
    justify-content: center;
    gap: 8px;
    width: 100%;
}

.main-nav button {
    background-color: rgba(255, 255, 255, 0.2);
    color: white;
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 0.9em;
    transition: background-color 0.3s ease;
    flex-grow: 1; /* Allow buttons to grow to fill space */
    max-width: 180px; /* Limit max width for larger screens */
}

.main-nav button:hover {
    background-color: rgba(255, 255, 255, 0.3);
}

.main-nav button.active {
    background-color: white;
    color: var(--primary-color);
    font-weight: bold;
}

.app-container {
    flex-grow: 1; /* Allows container to take available space */
    padding: var(--padding-base);
    max-width: 900px; /* Max width for larger screens */
    margin: 20px auto;
    width: 100%;
}

/* Utility Classes */
.hidden {
    display: none !important;
}

.view {
    background-color: var(--card-background);
    padding: var(--padding-base);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow);
    margin-bottom: 20px;
}

.view h2 {
    color: var(--primary-color);
    margin-bottom: var(--padding-base);
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 10px;
}

/* Forms */
.form-container {
    background-color: #f9f9f9;
    padding: var(--padding-base);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    margin-bottom: var(--padding-base);
}

.form-container h3 {
    color: var(--secondary-color);
    margin-bottom: 15px;
}

form {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

form label {
    font-weight: bold;
    margin-bottom: 2px;
}

form input[type="text"],
form input[type="date"],
form textarea,
form select {
    width: 100%;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    font-size: 1em;
}

form textarea {
    resize: vertical;
    min-height: 80px;
}

form .btn {
    margin-top: 10px;
}

/* Buttons */
.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.1s ease;
    white-space: nowrap; /* Prevent text wrapping */
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover {
    background-color: #43A047;
    transform: translateY(-1px);
}

.btn-secondary {
    background-color: var(--secondary-color);
    color: white;
}

.btn-secondary:hover {
    background-color: #546E7A;
    transform: translateY(-1px);
}

.btn-success {
    background-color: var(--success-color);
    color: white;
}

.btn-success:hover {
    background-color: #7CB342;
    transform: translateY(-1px);
}

.btn-danger {
    background-color: var(--danger-color);
    color: white;
}

.btn-danger:hover {
    background-color: #E53935;
    transform: translateY(-1px);
}

.btn-small {
    padding: 6px 12px;
    font-size: 0.85em;
}

.btn-group {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
}

/* Cards & Lists */
.card-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    margin-top: 20px;
}

.item-card {
    background-color: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius);
    padding: var(--padding-base);
    box-shadow: var(--shadow);
    display: flex;
    flex-direction: column;
    gap: 10px;
    position: relative;
}

.item-card h3 {
    color: var(--primary-color);
    margin-bottom: 5px;
    font-size: 1.3em;
}

.item-card p {
    font-size: 0.95em;
    color: var(--text-color);
}

.item-card .dates, .item-card .progress-info {
    font-size: 0.85em;
    color: #666;
}

.item-card .progress-bar-container {
    background-color: #e0e0e0;
    border-radius: 5px;
    height: 10px;
    margin-top: 5px;
    overflow: hidden;
}

.item-card .progress-bar {
    height: 100%;
    background-color: var(--success-color);
    border-radius: 5px;
    transition: width 0.5s ease-in-out;
}

.item-card .card-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: flex-end; /* Align buttons to the right */
    margin-top: 10px;
}

.simple-list {
    list-style: none;
    margin-top: 10px;
}

.simple-list li {
    background-color: #fefefe;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    padding: 10px 15px;
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 10px;
    word-break: break-word; /* Prevents long words from overflowing */
}

.simple-list li.completed {
    background-color: #e6ffe6;
    text-decoration: line-through;
    color: #666;
}

.simple-list li .task-actions {
    display: flex;
    gap: 5px;
}

.no-items-message, .info-message {
    text-align: center;
    color: #888;
    margin-top: 20px;
    font-style: italic;
}

/* Dashboard Summary Cards */
.summary-card {
    background-color: var(--card-background);
    padding: var(--padding-base);
    border-radius: var(--border-radius);
    box-shadow: var(--shadow);
    margin-bottom: var(--padding-base);
}

.summary-card h3 {
    color: var(--secondary-color);
    margin-bottom: 10px;
    border-bottom: 1px dashed var(--border-color);
    padding-bottom: 5px;
}

.summary-card p {
    margin-bottom: 5px;
}

/* Modals */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 100; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
    padding: 20px; /* Add padding for small screens */
}

.modal.visible {
    display: flex; /* Show the modal */
}

.modal-content {
    background-color: var(--card-background);
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow);
    max-width: 500px;
    width: 100%;
    position: relative;
    max-height: 90vh; /* Limit height for scrollable content */
    overflow-y: auto; /* Enable scroll for content */
}

.modal-content h3 {
    color: var(--primary-color);
    margin-bottom: var(--padding-base);
}

.modal-content form {
    margin-top: 15px;
}

.close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    position: absolute;
    top: 10px;
    right: 15px;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus {
    color: #333;
    text-decoration: none;
}

/* Responsive Adjustments */
@media (max-width: 600px) {
    .app-header h1 {
        font-size: 1.5em;
    }

    .main-nav {
        flex-direction: column; /* Stack buttons vertically on small screens */
        gap: 5px;
    }

    .main-nav button {
        width: 100%; /* Full width buttons */
        max-width: none;
    }

    .app-container {
        padding: 10px;
        margin: 10px auto;
    }

    .view, .summary-card {
        padding: 15px;
        margin-bottom: 15px;
    }

    .form-container {
        padding: 15px;
    }

    .btn {
        width: 100%;
        margin-bottom: 10px; /* Add space between stacked buttons */
    }

    .btn-group {
        flex-direction: column;
        gap: 10px;
    }

    .item-card .card-actions {
        flex-direction: column;
        align-items: stretch; /* Stretch buttons to full width */
    }

    .item-card .card-actions .btn {
        width: 100%;
    }

    .modal-content {
        padding: 20px;
    }
}

@media (min-width: 601px) and (max-width: 900px) {
    .app-container {
        padding: 15px;
    }
    .main-nav button {
        flex-grow: unset; /* Don't force them to grow too much */
        width: auto;
    }
}

/* Specific elements for export/import */
#import-file-name {
    margin-top: 10px;
    font-size: 0.9em;
    color: #555;
    text-align: left;
}

3. js/db.js (Manejo de IndexedDB)
Este archivo contendrá la lógica para interactuar con IndexedDB. Es crucial para la persistencia de datos.

JavaScript

// js/db.js

const DB_NAME = '12WeekYearDB';
const DB_VERSION = 1; // Increment this version if you change your database schema
const STORES = {
    CYCLES: 'cycles',
    GOALS: 'goals',
    TASKS: 'tasks'
};

let db;

/**
 * Abre la base de datos IndexedDB.
 * Si la base de datos no existe o la versión es más nueva, se creará/actualizará.
 * @returns {Promise<IDBDatabase>} Una promesa que resuelve con el objeto de la base de datos.
 */
function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);

        request.onerror = (event) => {
            console.error('Error al abrir IndexedDB:', event.target.errorCode);
            reject('Error al abrir la base de datos.');
        };

        request.onsuccess = (event) => {
            db = event.target.result;
            console.log('IndexedDB abierta con éxito.');
            resolve(db);
        };

        request.onupgradeneeded = (event) => {
            const db = event.target.result;

            // Crear o actualizar la Object Store para Ciclos
            if (!db.objectStoreNames.contains(STORES.CYCLES)) {
                db.createObjectStore(STORES.CYCLES, { keyPath: 'id', autoIncrement: true });
                console.log(`Object Store '${STORES.CYCLES}' creada.`);
            }

            // Crear o actualizar la Object Store para Metas
            if (!db.objectStoreNames.contains(STORES.GOALS)) {
                const goalsStore = db.createObjectStore(STORES.GOALS, { keyPath: 'id', autoIncrement: true });
                goalsStore.createIndex('cycleId', 'cycleId', { unique: false });
                console.log(`Object Store '${STORES.GOALS}' creada.`);
            }

            // Crear o actualizar la Object Store para Tareas
            if (!db.objectStoreNames.contains(STORES.TASKS)) {
                const tasksStore = db.createObjectStore(STORES.TASKS, { keyPath: 'id', autoIncrement: true });
                tasksStore.createIndex('goalId', 'goalId', { unique: false });
                tasksStore.createIndex('completed', 'completed', { unique: false });
                console.log(`Object Store '${STORES.TASKS}' creada.`);
            }

            console.log('Actualización de base de datos completada.');
        };
    });
}

/**
 * Realiza una transacción IndexedDB para añadir, obtener, actualizar o eliminar datos.
 * @param {string} storeName - El nombre de la Object Store (ej. 'cycles', 'goals').
 * @param {string} mode - El modo de la transacción ('readonly' o 'readwrite').
 * @param {function(IDBObjectStore): Promise<any>} callback - Una función que recibe la Object Store y devuelve una promesa.
 * @returns {Promise<any>} Una promesa que resuelve con el resultado de la operación o rechaza con un error.
 */
function transaction(storeName, mode, callback) {
    return new Promise((resolve, reject) => {
        if (!db) {
            console.error('IndexedDB no está abierta.');
            return reject('Base de datos no abierta.');
        }

        const tx = db.transaction(storeName, mode);
        const store = tx.objectStore(storeName);

        tx.oncomplete = () => resolve(result);
        tx.onerror = (event) => {
            console.error(`Error en la transacción [${storeName}, ${mode}]:`, event.target.error);
            reject(event.target.error);
        };

        let result;
        try {
            // El callback se encarga de la operación (add, get, put, delete) y de establecer el resultado.
            // Es importante que el callback devuelva la request para que el resultado se resuelva en oncomplete
            const request = callback(store);
            request.onsuccess = (e) => {
                result = e.target.result;
            };
            request.onerror = (e) => {
                console.error(`Error en la operación de ${storeName}:`, e.target.error);
                reject(e.target.error);
            };
        } catch (e) {
            reject(e); // Captura errores sincrónicos dentro del callback
        }
    });
}


/**
 * Añade un nuevo objeto a una Object Store.
 * @param {string} storeName
 * @param {object} item
 * @returns {Promise<number>} La clave generada para el nuevo objeto.
 */
async function add(storeName, item) {
    return transaction(storeName, 'readwrite', (store) => store.add(item));
}

/**
 * Obtiene un objeto por su ID de una Object Store.
 * @param {string} storeName
 * @param {number} id
 * @returns {Promise<object|undefined>} El objeto o undefined si no se encuentra.
 */
async function get(storeName, id) {
    return transaction(storeName, 'readonly', (store) => store.get(id));
}

/**
 * Actualiza un objeto existente en una Object Store.
 * @param {string} storeName
 * @param {object} item - El objeto a actualizar (debe contener el keyPath 'id').
 * @returns {Promise<number>} La clave del objeto actualizado.
 */
async function update(storeName, item) {
    return transaction(storeName, 'readwrite', (store) => store.put(item));
}

/**
 * Elimina un objeto por su ID de una Object Store.
 * @param {string} storeName
 * @param {number} id
 * @returns {Promise<void>}
 */
async function remove(storeName, id) {
    return transaction(storeName, 'readwrite', (store) => store.delete(id));
}

/**
 * Obtiene todos los objetos de una Object Store.
 * @param {string} storeName
 * @returns {Promise<Array<object>>} Un array de todos los objetos.
 */
async function getAll(storeName) {
    return transaction(storeName, 'readonly', (store) => store.getAll());
}

/**
 * Obtiene objetos de una Object Store por un índice.
 * @param {string} storeName
 * @param {string} indexName
 * @param {IDBValidKey | IDBKeyRange} query
 * @returns {Promise<Array<object>>} Un array de objetos que coinciden con la consulta.
 */
async function getByIndex(storeName, indexName, query) {
    return transaction(storeName, 'readonly', (store) => store.index(indexName).getAll(query));
}

/**
 * Limpia todas las Object Stores. Usado para importación de datos.
 * @returns {Promise<void>}
 */
async function clearAllStores() {
    return new Promise((resolve, reject) => {
        if (!db) {
            console.error('IndexedDB no está abierta.');
            return reject('Base de datos no abierta.');
        }
        const tx = db.transaction(Object.values(STORES), 'readwrite');

        tx.oncomplete = () => {
            console.log('Todas las stores limpiadas.');
            resolve();
        };
        tx.onerror = (event) => {
            console.error('Error al limpiar stores:', event.target.error);
            reject(event.target.error);
        };

        for (const storeName of Object.values(STORES)) {
            tx.objectStore(storeName).clear();
        }
    });
}

// Exportar las funciones para que sean accesibles en otros módulos
export { openDB, add, get, update, remove, getAll, getByIndex, clearAllStores, STORES };

4. js/models.js (Los Modelos de Datos)
Aquí definimos las clases para nuestros objetos de datos: Ciclo, Meta y Tarea.

JavaScript

// js/models.js

// Usamos el patrón de clases para los modelos de datos
// Esto ayuda a organizar la estructura y la lógica relacionada con los datos

/**
 * Representa un Ciclo de 12 Semanas.
 */
class Cycle {
    constructor(name, startDate, id = null) {
        this.id = id; // ID será autogenerado por IndexedDB si es nuevo
        this.name = name;
        this.startDate = startDate; // Formato 'YYYY-MM-DD'
        this.endDate = this.calculateEndDate(startDate); // Calculada automáticamente
        this.createdAt = new Date().toISOString(); // Marca de tiempo de creación
    }

    /**
     * Calcula la fecha de fin de un ciclo (12 semanas después de la fecha de inicio).
     * @param {string} startDateString - La fecha de inicio en formato 'YYYY-MM-DD'.
     * @returns {string} La fecha de fin en formato 'YYYY-MM-DD'.
     */
    calculateEndDate(startDateString) {
        const startDate = new Date(startDateString + 'T00:00:00'); // Añadir 'T00:00:00' para evitar problemas de zona horaria
        startDate.setDate(startDate.getDate() + (12 * 7) - 1); // 12 semanas * 7 días - 1 día para que el último día sea inclusivo
        return startDate.toISOString().split('T')[0];
    }

    /**
     * Calcula el progreso de un ciclo basado en el progreso de sus metas.
     * Esto se calculará en el controlador, no es una propiedad del modelo en sí.
     * @returns {number} Porcentaje de progreso (0-100).
     */
    // getProgress(goals) { ... lógica en el controlador }
}

/**
 * Representa una Meta dentro de un Ciclo.
 */
class Goal {
    constructor(cycleId, name, description, target, id = null) {
        this.id = id;
        this.cycleId = cycleId; // Relación con el ciclo al que pertenece
        this.name = name;
        this.description = description;
        this.target = target; // Métrica o resultado deseado
        this.completed = false; // Estado de completitud
        this.progress = 0; // Porcentaje de progreso de la meta (0-100)
        this.createdAt = new Date().toISOString();
    }
}

/**
 * Representa una Tarea dentro de una Meta.
 */
class Task {
    constructor(goalId, name, dueDate = null, id = null) {
        this.id = id;
        this.goalId = goalId; // Relación con la meta a la que pertenece
        this.name = name;
        this.dueDate = dueDate; // Formato 'YYYY-MM-DD', opcional
        this.completed = false; // Estado de completitud de la tarea
        this.createdAt = new Date().toISOString();
    }
}

// Exportar las clases para que puedan ser usadas en otros archivos
export { Cycle, Goal, Task };

5. js/views.js (La Lógica de la Vista y Renderizado)
Este archivo maneja la manipulación del DOM y el renderizado de la interfaz de usuario.

JavaScript

// js/views.js

// Selectores de elementos DOM
const DOMElements = {
    // Navigations
    navHomeBtn: document.getElementById('nav-home'),
    navCyclesBtn: document.getElementById('nav-cycles'),
    navGoalsBtn: document.getElementById('nav-goals'),
    navExportImportBtn: document.getElementById('nav-export-import'),

    // Views
    dashboardView: document.getElementById('dashboard-view'),
    cyclesView: document.getElementById('cycles-view'),
    goalsView: document.getElementById('goals-view'),
    exportImportView: document.getElementById('export-import-view'),

    // Dashboard
    activeCycleSummary: document.getElementById('active-cycle-summary'),
    currentCycleName: document.getElementById('current-cycle-name'),
    currentCycleDates: document.getElementById('current-cycle-dates'),
    currentCycleProgress: document.getElementById('current-cycle-progress'),
    currentCycleProgressBar: document.getElementById('current-cycle-progress-bar'),
    viewActiveCycleDetailsBtn: document.getElementById('view-active-cycle-details'),
    upcomingItemsList: document.getElementById('upcoming-items-list'),


    // Cycle Management
    addCycleBtn: document.getElementById('add-cycle-btn'),
    cycleFormContainer: document.getElementById('cycle-form-container'),
    cycleFormTitle: document.getElementById('cycle-form-title'),
    cycleForm: document.getElementById('cycle-form'),
    cycleIdInput: document.getElementById('cycle-id'),
    cycleNameInput: document.getElementById('cycle-name'),
    cycleStartDateInput: document.getElementById('cycle-start-date'),
    cancelCycleFormBtn: document.getElementById('cancel-cycle-form-btn'),
    cyclesList: document.getElementById('cycles-list'),

    // Goal Management
    selectCycleForGoals: document.getElementById('select-cycle-for-goals'),
    noCycleSelectedMessage: document.getElementById('no-cycle-selected-message'),
    addGoalBtn: document.getElementById('add-goal-btn'),
    goalFormContainer: document.getElementById('goal-form-container'),
    goalFormTitle: document.getElementById('goal-form-title'),
    goalForm: document.getElementById('goal-form'),
    goalIdInput: document.getElementById('goal-id'),
    goalCycleIdInput: document.getElementById('goal-cycle-id'),
    goalNameInput: document.getElementById('goal-name'),
    goalDescriptionInput: document.getElementById('goal-description'),
    goalTargetInput: document.getElementById('goal-target'),
    cancelGoalFormBtn: document.getElementById('cancel-goal-form-btn'),
    currentCycleGoalsName: document.getElementById('current-cycle-goals-name'),
    goalsList: document.getElementById('goals-list'),

    // Task Modal
    taskModal: document.getElementById('task-modal'),
    taskModalTitle: document.getElementById('task-modal-title'),
    modalGoalIdInput: document.getElementById('modal-goal-id'),
    addTaskBtn: document.getElementById('add-task-btn'),
    taskFormContainer: document.getElementById('task-form-container'),
    taskFormTitle: document.getElementById('task-form-title'),
    taskForm: document.getElementById('task-form'),
    taskIdInput: document.getElementById('task-id'),
    taskNameInput: document.getElementById('task-name'),
    taskDueDateInput: document.getElementById('task-due-date'),
    cancelTaskFormBtn: document.getElementById('cancel-task-form-btn'),
    tasksList: document.getElementById('tasks-list'),
    closeTaskModalBtn: document.querySelector('#task-modal .close-button'),

    // Confirm Modal
    confirmModal: document.getElementById('confirm-modal'),
    confirmModalMessage: document.getElementById('confirm-modal-message'),
    confirmDeleteBtn: document.getElementById('confirm-delete-btn'),
    cancelDeleteBtn: document.getElementById('cancel-delete-btn'),
    closeConfirmModalBtn: document.querySelector('#confirm-modal .close-button'),

    // Export/Import
    exportDataBtn: document.getElementById('export-data-btn'),
    importFileInput: document.getElementById('import-file-input'),
    importDataBtn: document.getElementById('import-data-btn'),
    confirmImportBtn: document.getElementById('confirm-import-btn'),
    cancelImportBtn: document.getElementById('cancel-import-btn'),
    importFileName: document.getElementById('import-file-name')
};

/**
 * Renderiza la vista activa, ocultando las demás.
 * @param {HTMLElement} viewToShow - El elemento de la vista a mostrar.
 * @param {HTMLElement} activeNavButton - El botón de navegación que debe estar activo.
 */
function renderView(viewToShow, activeNavButton) {
    // Ocultar todas las vistas
    DOMElements.dashboardView.classList.add('hidden');
    DOMElements.cyclesView.classList.add('hidden');
    DOMElements.goalsView.classList.add('hidden');
    DOMElements.exportImportView.classList.add('hidden');

    // Mostrar la vista deseada
    viewToShow.classList.remove('hidden');

    // Quitar 'active' de todos los botones de navegación
    DOMElements.navHomeBtn.classList.remove('active');
    DOMElements.navCyclesBtn.classList.remove('active');
    DOMElements.navGoalsBtn.classList.remove('active');
    DOMElements.navExportImportBtn.classList.remove('active');

    // Activar el botón de navegación correspondiente
    if (activeNavButton) {
        activeNavButton.classList.add('active');
    }
}

/**
 * Muestra u oculta el formulario para crear/editar.
 * @param {HTMLElement} formContainer - El contenedor del formulario.
 * @param {HTMLElement} formTitleElement - El elemento del título del formulario.
 * @param {string} titleText - El texto del título del formulario.
 * @param {object|null} data - Los datos para poblar el formulario (para edición), o null para creación.
 * @param {Function} resetFormCallback - Función para resetear el formulario.
 */
function toggleForm(formContainer, formTitleElement, titleText, data, resetFormCallback) {
    formTitleElement.textContent = titleText;
    formContainer.classList.toggle('hidden');
    resetFormCallback(data);
}

/**
 * Renderiza la lista de ciclos.
 * @param {Array<Object>} cycles - Array de objetos Cycle.
 * @param {Function} onEdit - Callback para editar un ciclo.
 * @param {Function} onDelete - Callback para eliminar un ciclo.
 * @param {Function} onSelectForGoals - Callback para seleccionar un ciclo para ver metas.
 */
function renderCycles(cycles, onEdit, onDelete, onSelectForGoals) {
    DOMElements.cyclesList.innerHTML = '';
    if (cycles.length === 0) {
        DOMElements.cyclesList.innerHTML = '<p class="no-items-message">No hay ciclos creados aún.</p>';
        return;
    }

    cycles.forEach(cycle => {
        const cycleCard = document.createElement('div');
        cycleCard.className = 'item-card';
        cycleCard.dataset.id = cycle.id;

        cycleCard.innerHTML = `
            <h3><img src="assets/icon_cycle.png" alt="Ciclo" class="card-icon" style="height: 24px; vertical-align: middle; margin-right: 8px;">${cycle.name}</h3>
            <p class="dates">Inicio: ${cycle.startDate} | Fin: ${cycle.endDate}</p>
            <div class="card-actions">
                <button class="btn btn-secondary btn-small edit-cycle-btn">Editar</button>
                <button class="btn btn-danger btn-small delete-cycle-btn">Eliminar</button>
                <button class="btn btn-primary btn-small view-goals-btn">Ver Metas</button>
            </div>
        `;
        DOMElements.cyclesList.appendChild(cycleCard);

        cycleCard.querySelector('.edit-cycle-btn').onclick = () => onEdit(cycle.id);
        cycleCard.querySelector('.delete-cycle-btn').onclick = () => onDelete(cycle.id, 'ciclo', cycle.name);
        cycleCard.querySelector('.view-goals-btn').onclick = () => onSelectForGoals(cycle.id);
    });
}

/**
 * Renderiza el selector de ciclos para la vista de metas.
 * @param {Array<Object>} cycles - Array de objetos Cycle.
 * @param {number|null} selectedCycleId - ID del ciclo actualmente seleccionado.
 */
function renderCycleSelectForGoals(cycles, selectedCycleId = null) {
    DOMElements.selectCycleForGoals.innerHTML = '<option value="">Selecciona un Ciclo</option>';
    cycles.forEach(cycle => {
        const option = document.createElement('option');
        option.value = cycle.id;
        option.textContent = cycle.name;
        if (cycle.id === selectedCycleId) {
            option.selected = true;
        }
        DOMElements.selectCycleForGoals.appendChild(option);
    });
}

/**
 * Renderiza la lista de metas para un ciclo específico.
 * @param {Array<Object>} goals - Array de objetos Goal.
 * @param {Function} onEdit - Callback para editar una meta.
 * @param {Function} onDelete - Callback para eliminar una meta.
 * @param {Function} onManageTasks - Callback para gestionar tareas de una meta.
 * @param {Function} onUpdateGoalProgress - Callback para actualizar el progreso de una meta.
 */
function renderGoals(goals, onEdit, onDelete, onManageTasks, onUpdateGoalProgress) {
    DOMElements.goalsList.innerHTML = '';
    DOMElements.currentCycleGoalsName.textContent = goals.length > 0 ? goals[0].cycleName : '';

    if (goals.length === 0) {
        DOMElements.goalsList.innerHTML = '<p class="no-items-message">No hay metas para este ciclo aún.</p>';
        return;
    }

    goals.forEach(goal => {
        const goalCard = document.createElement('div');
        goalCard.className = 'item-card';
        goalCard.dataset.id = goal.id;

        const progressPercent = goal.progress || 0; // Asegurar que sea al menos 0

        goalCard.innerHTML = `
            <h3><img src="assets/icon_goal.png" alt="Meta" class="card-icon" style="height: 24px; vertical-align: middle; margin-right: 8px;">${goal.name}</h3>
            <p><strong>Descripción:</strong> ${goal.description}</p>
            <p><strong>Objetivo:</strong> ${goal.target}</p>
            <p class="progress-info">Progreso: ${progressPercent.toFixed(0)}%</p>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: ${progressPercent}%;"></div>
            </div>
            <div class="card-actions">
                <button class="btn btn-secondary btn-small edit-goal-btn">Editar</button>
                <button class="btn btn-danger btn-small delete-goal-btn">Eliminar</button>
                <button class="btn btn-info btn-small manage-tasks-btn">Tareas (${goal.tasksCount || 0})</button>
                <input type="range" min="0" max="100" value="${progressPercent}" class="progress-slider" data-goal-id="${goal.id}">
            </div>
        `;
        DOMElements.goalsList.appendChild(goalCard);

        goalCard.querySelector('.edit-goal-btn').onclick = () => onEdit(goal.id);
        goalCard.querySelector('.delete-goal-btn').onclick = () => onDelete(goal.id, 'meta', goal.name);
        goalCard.querySelector('.manage-tasks-btn').onclick = () => onManageTasks(goal.id, goal.name);

        const progressSlider = goalCard.querySelector('.progress-slider');
        // Usar 'onchange' para evitar múltiples llamadas mientras se arrastra
        // y 'oninput' para actualizar visualmente la barra de progreso en tiempo real.
        progressSlider.oninput = (e) => {
            const bar = e.target.previousElementSibling; // La barra de progreso es el div justo antes del slider
            const info = bar.previousElementSibling; // El párrafo de info es el anterior al contenedor de la barra
            const value = e.target.value;
            bar.style.width = `${value}%`;
            info.textContent = `Progreso: ${value}%`;
        };
        progressSlider.onchange = (e) => onUpdateGoalProgress(goal.id, parseInt(e.target.value));
    });
}

/**
 * Renderiza la lista de tareas dentro del modal.
 * @param {Array<Object>} tasks - Array de objetos Task.
 * @param {Function} onToggleComplete - Callback para marcar/desmarcar tarea.
 * @param {Function} onDelete - Callback para eliminar tarea.
 */
function renderTasks(tasks, onToggleComplete, onDelete) {
    DOMElements.tasksList.innerHTML = '';
    if (tasks.length === 0) {
        DOMElements.tasksList.innerHTML = '<p class="no-items-message">No hay tareas para esta meta aún.</p>';
        return;
    }

    tasks.forEach(task => {
        const taskItem = document.createElement('li');
        taskItem.dataset.id = task.id;
        if (task.completed) {
            taskItem.classList.add('completed');
        }

        const dueDateText = task.dueDate ? ` (Hasta: ${task.dueDate})` : '';
        taskItem.innerHTML = `
            <span>${task.name}${dueDateText}</span>
            <div class="task-actions">
                <button class="btn btn-small btn-secondary toggle-complete-task-btn">
                    ${task.completed ? 'Deshacer' : 'Completar'}
                </button>
                <button class="btn btn-small btn-danger delete-task-btn">Eliminar</button>
            </div>
        `;
        DOMElements.tasksList.appendChild(taskItem);

        taskItem.querySelector('.toggle-complete-task-btn').onclick = () => onToggleComplete(task.id);
        taskItem.querySelector('.delete-task-btn').onclick = () => onDelete(task.id, 'tarea', task.name);
    });
}

/**
 * Muestra el modal de confirmación.
 * @param {string} message - Mensaje a mostrar.
 * @param {Function} onConfirm - Callback cuando se confirma.
 */
function showConfirmModal(message, onConfirm) {
    DOMElements.confirmModalMessage.textContent = message;
    DOMElements.confirmDeleteBtn.onclick = onConfirm;
    DOMElements.confirmModal.classList.add('visible');
}

/**
 * Oculta el modal de confirmación.
 */
function hideConfirmModal() {
    DOMElements.confirmModal.classList.remove('visible');
}

/**
 * Muestra el modal de tareas.
 * @param {number} goalId - ID de la meta a la que pertenecen las tareas.
 * @param {string} goalName - Nombre de la meta.
 */
function showTaskModal(goalId, goalName) {
    DOMElements.modalGoalIdInput.value = goalId;
    DOMElements.taskModalTitle.textContent = `Tareas para: ${goalName}`;
    DOMElements.taskModal.classList.add('visible');
    DOMElements.taskFormContainer.classList.add('hidden'); // Ocultar formulario al abrir modal
    resetTaskForm();
}

/**
 * Oculta el modal de tareas.
 */
function hideTaskModal() {
    DOMElements.taskModal.classList.remove('visible');
}

/**
 * Resetea y (opcionalmente) puebla el formulario de ciclo.
 * @param {object|null} cycle - Objeto Cycle para poblar el formulario.
 */
function resetCycleForm(cycle = null) {
    DOMElements.cycleForm.reset();
    DOMElements.cycleIdInput.value = '';
    if (cycle) {
        DOMElements.cycleIdInput.value = cycle.id;
        DOMElements.cycleNameInput.value = cycle.name;
        DOMElements.cycleStartDateInput.value = cycle.startDate;
        DOMElements.cycleFormTitle.textContent = `Editar Ciclo: ${cycle.name}`;
    } else {
        DOMElements.cycleFormTitle.textContent = `Crear Nuevo Ciclo`;
    }
}

/**
 * Resetea y (opcionalmente) puebla el formulario de meta.
 * @param {object|null} goal - Objeto Goal para poblar el formulario.
 */
function resetGoalForm(goal = null) {
    DOMElements.goalForm.reset();
    DOMElements.goalIdInput.value = '';
    DOMElements.goalCycleIdInput.value = DOMElements.selectCycleForGoals.value; // Asegurarse de que el ID del ciclo esté siempre en el input oculto
    if (goal) {
        DOMElements.goalIdInput.value = goal.id;
        DOMElements.goalNameInput.value = goal.name;
        DOMElements.goalDescriptionInput.value = goal.description;
        DOMElements.goalTargetInput.value = goal.target;
        DOMElements.goalFormTitle.textContent = `Editar Meta: ${goal.name}`;
    } else {
        DOMElements.goalFormTitle.textContent = `Crear Nueva Meta`;
    }
}

/**
 * Resetea y (opcionalmente) puebla el formulario de tarea.
 * @param {object|null} task - Objeto Task para poblar el formulario.
 */
function resetTaskForm(task = null) {
    DOMElements.taskForm.reset();
    DOMElements.taskIdInput.value = '';
    DOMElements.modalGoalIdInput.value = DOMElements.modalGoalIdInput.value; // Mantener el goalId
    if (task) {
        DOMElements.taskIdInput.value = task.id;
        DOMElements.taskNameInput.value = task.name;
        DOMElements.taskDueDateInput.value = task.dueDate;
        DOMElements.taskFormTitle.textContent = `Editar Tarea: ${task.name}`;
    } else {
        DOMElements.taskFormTitle.textContent = `Crear Nueva Tarea`;
    }
}

/**
 * Actualiza el resumen del ciclo activo en el dashboard.
 * @param {Object|null} activeCycle - El objeto Cycle activo o null.
 * @param {number} totalProgress - El progreso total del ciclo (0-100).
 */
function updateDashboardActiveCycle(activeCycle, totalProgress) {
    if (activeCycle) {
        DOMElements.currentCycleName.textContent = activeCycle.name;
        DOMElements.currentCycleDates.textContent = `Inicio: ${activeCycle.startDate} | Fin: ${activeCycle.endDate}`;
        DOMElements.currentCycleProgress.textContent = `Progreso General: ${totalProgress.toFixed(0)}%`;
        DOMElements.currentCycleProgressBar.style.width = `${totalProgress}%`;
        DOMElements.activeCycleSummary.classList.remove('no-active-cycle');
        DOMElements.viewActiveCycleDetailsBtn.style.display = 'inline-block';
        DOMElements.viewActiveCycleDetailsBtn.onclick = () => {
             // Navegar a la vista de metas y seleccionar este ciclo
            DOMElements.navGoalsBtn.click(); // Simular clic en botón de Metas
            DOMElements.selectCycleForGoals.value = activeCycle.id;
            const event = new Event('change');
            DOMElements.selectCycleForGoals.dispatchEvent(event); // Disparar evento change
        };
    } else {
        DOMElements.currentCycleName.textContent = 'No hay ciclo activo.';
        DOMElements.currentCycleDates.textContent = '';
        DOMElements.currentCycleProgress.textContent = 'Progreso General: 0%';
        DOMElements.currentCycleProgressBar.style.width = '0%';
        DOMElements.activeCycleSummary.classList.add('no-active-cycle');
        DOMElements.viewActiveCycleDetailsBtn.style.display = 'none';
    }
}

/**
 * Actualiza la lista de próximos items en el dashboard.
 * @param {Array<Object>} items - Array de metas/tareas próximas.
 */
function updateDashboardUpcomingItems(items) {
    DOMElements.upcomingItemsList.innerHTML = '';
    if (items.length === 0) {
        DOMElements.upcomingItemsList.innerHTML = '<li>No hay tareas o metas próximas.</li>';
        return;
    }
    items.forEach(item => {
        const li = document.createElement('li');
        const type = item.type === 'goal' ? 'Meta' : 'Tarea';
        const dateInfo = item.dueDate ? ` (hasta ${item.dueDate})` : '';
        li.textContent = `${type}: ${item.name} ${dateInfo}`;
        DOMElements.upcomingItemsList.appendChild(li);
    });
}

/**
 * Muestra el selector de archivo de importación y el nombre del archivo.
 * @param {File|null} file - El objeto File seleccionado, o null para resetear.
 */
function showImportFileSelection(file) {
    if (file) {
        DOMElements.importFileName.textContent = `Archivo seleccionado: ${file.name}`;
        DOMElements.confirmImportBtn.classList.remove('hidden');
        DOMElements.cancelImportBtn.classList.remove('hidden');
        DOMElements.importDataBtn.classList.add('hidden'); // Ocultar botón "Seleccionar"
    } else {
        DOMElements.importFileName.textContent = '';
        DOMElements.confirmImportBtn.classList.add('hidden');
        DOMElements.cancelImportBtn.classList.add('hidden');
        DOMElements.importDataBtn.classList.remove('hidden');
        DOMElements.importFileInput.value = ''; // Resetear el input file
    }
}


export {
    DOMElements,
    renderView,
    toggleForm,
    renderCycles,
    renderCycleSelectForGoals,
    renderGoals,
    renderTasks,
    showConfirmModal,
    hideConfirmModal,
    showTaskModal,
    hideTaskModal,
    resetCycleForm,
    resetGoalForm,
    resetTaskForm,
    updateDashboardActiveCycle,
    updateDashboardUpcomingItems,
    showImportFileSelection
};
6. js/controllers.js (La Lógica del Controlador)
Aquí reside la lógica de negocio, manejo de eventos y la orquestación entre modelos y vistas.

JavaScript

// js/controllers.js

import { STORES, add, get, update, remove, getAll, getByIndex, clearAllStores } from './db.js';
import { Cycle, Goal, Task } from './models.js';
import {
    DOMElements,
    renderView,
    toggleForm,
    renderCycles,
    renderCycleSelectForGoals,
    renderGoals,
    renderTasks,
    showConfirmModal,
    hideConfirmModal,
    showTaskModal,
    hideTaskModal,
    resetCycleForm,
    resetGoalForm,
    resetTaskForm,
    updateDashboardActiveCycle,
    updateDashboardUpcomingItems,
    showImportFileSelection
} from './views.js';

let currentSelectedCycleId = null; // ID del ciclo actualmente seleccionado en la vista de Metas
let confirmActionCallback = null; // Callback para el modal de confirmación

/**
 * Inicializa los controladores de eventos para la aplicación.
 */
function initControllers() {
    // --- Navegación ---
    DOMElements.navHomeBtn.addEventListener('click', () => {
        renderView(DOMElements.dashboardView, DOMElements.navHomeBtn);
        loadDashboardData();
    });
    DOMElements.navCyclesBtn.addEventListener('click', () => {
        renderView(DOMElements.cyclesView, DOMElements.navCyclesBtn);
        loadCycles();
    });
    DOMElements.navGoalsBtn.addEventListener('click', () => {
        renderView(DOMElements.goalsView, DOMElements.navGoalsBtn);
        loadGoalsViewData();
    });
    DOMElements.navExportImportBtn.addEventListener('click', () => {
        renderView(DOMElements.exportImportView, DOMElements.navExportImportBtn);
        showImportFileSelection(null); // Resetear selector al entrar a la vista
    });


    // --- Ciclos ---
    DOMElements.addCycleBtn.addEventListener('click', () => {
        toggleForm(DOMElements.cycleFormContainer, DOMElements.cycleFormTitle, 'Crear Nuevo Ciclo', null, resetCycleForm);
    });

    DOMElements.cancelCycleFormBtn.addEventListener('click', () => {
        DOMElements.cycleFormContainer.classList.add('hidden');
        resetCycleForm();
    });

    DOMElements.cycleForm.addEventListener('submit', handleCycleFormSubmit);

    // --- Metas ---
    DOMElements.selectCycleForGoals.addEventListener('change', handleCycleSelectForGoalsChange);

    DOMElements.addGoalBtn.addEventListener('click', () => {
        toggleForm(DOMElements.goalFormContainer, DOMElements.goalFormTitle, 'Crear Nueva Meta', null, resetGoalForm);
    });

    DOMElements.cancelGoalFormBtn.addEventListener('click', () => {
        DOMElements.goalFormContainer.classList.add('hidden');
        resetGoalForm();
    });

    DOMElements.goalForm.addEventListener('submit', handleGoalFormSubmit);

    // --- Tareas Modal ---
    DOMElements.addTaskBtn.addEventListener('click', () => {
        toggleForm(DOMElements.taskFormContainer, DOMElements.taskFormTitle, 'Crear Nueva Tarea', null, resetTaskForm);
    });

    DOMElements.cancelTaskFormBtn.addEventListener('click', () => {
        DOMElements.taskFormContainer.classList.add('hidden');
        resetTaskForm();
    });

    DOMElements.taskForm.addEventListener('submit', handleTaskFormSubmit);

    DOMElements.closeTaskModalBtn.addEventListener('click', hideTaskModal);
    // Cerrar modal al hacer clic fuera de él
    DOMElements.taskModal.addEventListener('click', (e) => {
        if (e.target === DOMElements.taskModal) {
            hideTaskModal();
        }
    });

    // --- Confirmación de Eliminación Modal ---
    DOMElements.confirmDeleteBtn.addEventListener('click', () => {
        if (confirmActionCallback) {
            confirmActionCallback();
        }
        hideConfirmModal();
    });
    DOMElements.cancelDeleteBtn.addEventListener('click', hideConfirmModal);
    DOMElements.closeConfirmModalBtn.addEventListener('click', hideConfirmModal);
    DOMElements.confirmModal.addEventListener('click', (e) => {
        if (e.target === DOMElements.confirmModal) {
            hideConfirmModal();
        }
    });


    // --- Exportar / Importar ---
    DOMElements.exportDataBtn.addEventListener('click', exportData);
    DOMElements.importDataBtn.addEventListener('click', () => DOMElements.importFileInput.click()); // Simular clic en input file
    DOMElements.importFileInput.addEventListener('change', handleImportFileChange);
    DOMElements.confirmImportBtn.addEventListener('click', confirmImportData);
    DOMElements.cancelImportBtn.addEventListener('click', () => showImportFileSelection(null));


    // Cargar dashboard al inicio
    loadDashboardData();
}

/**
 * Carga y muestra los datos del dashboard.
 */
async function loadDashboardData() {
    try {
        const cycles = await getAll(STORES.CYCLES);
        const now = new Date();
        now.setHours(0, 0, 0, 0); // Normalizar a inicio del día
        const activeCycle = cycles.find(c => {
            const startDate = new Date(c.startDate + 'T00:00:00');
            const endDate = new Date(c.endDate + 'T00:00:00');
            return now >= startDate && now <= endDate;
        });

        let totalProgress = 0;
        let upcomingItems = [];

        if (activeCycle) {
            const goals = await getByIndex(STORES.GOALS, 'cycleId', activeCycle.id);
            if (goals.length > 0) {
                const totalGoalsProgress = goals.reduce((sum, goal) => sum + (goal.progress || 0), 0);
                totalProgress = totalGoalsProgress / goals.length;
            }

            // Obtener tareas próximas para el ciclo activo
            for (const goal of goals) {
                const tasks = await getByIndex(STORES.TASKS, 'goalId', goal.id);
                // Filtrar tareas no completadas y con fecha límite en el futuro cercano (ej. próximas 2 semanas)
                const relevantTasks = tasks.filter(t =>
                    !t.completed &&
                    t.dueDate &&
                    new Date(t.dueDate + 'T00:00:00') >= now &&
                    new Date(t.dueDate + 'T00:00:00') <= new Date(now.getTime() + (14 * 24 * 60 * 60 * 1000)) // Próximos 14 días
                ).map(t => ({ ...t, type: 'task' }));
                upcomingItems.push(...relevantTasks);
            }

            // Considerar metas próximas sin tareas si no hay un buen progreso (ej. < 50%)
            const relevantGoals = goals.filter(g =>
                (g.progress || 0) < 50 &&
                !g.completed && // Asumiendo que Goal tendrá un campo 'completed'
                new Date(activeCycle.endDate + 'T00:00:00') >= now && // Meta aún dentro del ciclo activo
                new Date(activeCycle.endDate + 'T00:00:00') <= new Date(now.getTime() + (14 * 24 * 60 * 60 * 1000)) // Ciclo termina en 14 días
            ).map(g => ({ ...g, type: 'goal', dueDate: activeCycle.endDate })); // Usar endDate del ciclo como referencia

            upcomingItems.push(...relevantGoals);

            // Ordenar por fecha límite (tareas con fecha límite primero, luego metas por fin de ciclo)
            upcomingItems.sort((a, b) => {
                const dateA = new Date(a.dueDate || '9999-12-31'); // Poner fechas no definidas al final
                const dateB = new Date(b.dueDate || '9999-12-31');
                return dateA - dateB;
            });

        } else {
            console.log('No active cycle found.');
        }

        updateDashboardActiveCycle(activeCycle, totalProgress);
        updateDashboardUpcomingItems(upcomingItems.slice(0, 5)); // Mostrar solo los 5 más próximos

    } catch (error) {
        console.error('Error al cargar datos del dashboard:', error);
        alert('Error al cargar el dashboard. Consulta la consola para más detalles.');
    }
}


/**
 * Carga y renderiza la lista de ciclos.
 */
async function loadCycles() {
    try {
        const cycles = await getAll(STORES.CYCLES);
        renderCycles(cycles, editCycle, deleteCycle, selectCycleAndShowGoals);
        DOMElements.cycleFormContainer.classList.add('hidden'); // Asegurarse de que el formulario esté oculto al cargar la lista
        resetCycleForm();
    } catch (error) {
        console.error('Error al cargar ciclos:', error);
        alert('Error al cargar los ciclos. Consulta la consola para más detalles.');
    }
}

/**
 * Maneja el envío del formulario de ciclo (crear/editar).
 * @param {Event} event
 */
async function handleCycleFormSubmit(event) {
    event.preventDefault();

    const id = DOMElements.cycleIdInput.value ? parseInt(DOMElements.cycleIdInput.value) : null;
    const name = DOMElements.cycleNameInput.value.trim();
    const startDate = DOMElements.cycleStartDateInput.value;

    if (!name || !startDate) {
        alert('Por favor, completa todos los campos requeridos para el ciclo.');
        return;
    }

    try {
        if (id) {
            // Editar ciclo existente
            const existingCycle = await get(STORES.CYCLES, id);
            const updatedCycle = new Cycle(name, startDate, id);
            // Mantener propiedades originales que no se editan desde el formulario si existen
            updatedCycle.createdAt = existingCycle.createdAt; // Mantener la fecha de creación original
            await update(STORES.CYCLES, updatedCycle);
            alert('Ciclo actualizado con éxito!');
        } else {
            // Crear nuevo ciclo
            const newCycle = new Cycle(name, startDate);
            await add(STORES.CYCLES, newCycle);
            alert('Ciclo creado con éxito!');
        }
        DOMElements.cycleFormContainer.classList.add('hidden');
        loadCycles(); // Recargar la lista de ciclos
        loadDashboardData(); // Actualizar dashboard
    } catch (error) {
        console.error('Error al guardar ciclo:', error);
        alert('Error al guardar el ciclo. Consulta la consola para más detalles.');
    }
}

/**
 * Carga un ciclo en el formulario para edición.
 * @param {number} cycleId - ID del ciclo a editar.
 */
async function editCycle(cycleId) {
    try {
        const cycle = await get(STORES.CYCLES, cycleId);
        if (cycle) {
            toggleForm(DOMElements.cycleFormContainer, DOMElements.cycleFormTitle, `Editar Ciclo: ${cycle.name}`, cycle, resetCycleForm);
        } else {
            alert('Ciclo no encontrado para edición.');
        }
    } catch (error) {
        console.error('Error al cargar ciclo para edición:', error);
        alert('Error al cargar ciclo para edición. Consulta la consola para más detalles.');
    }
}

/**
 * Elimina un ciclo y sus metas y tareas asociadas.
 * @param {number} cycleId - ID del ciclo a eliminar.
 * @param {string} itemType - Tipo de ítem (para el mensaje de confirmación).
 * @param {string} itemName - Nombre del ítem (para el mensaje de confirmación).
 */
function deleteCycle(cycleId, itemType, itemName) {
    confirmActionCallback = async () => {
        try {
            // Obtener todas las metas del ciclo
            const goalsToDelete = await getByIndex(STORES.GOALS, 'cycleId', cycleId);

            // Eliminar todas las tareas asociadas a esas metas
            for (const goal of goalsToDelete) {
                const tasksToDelete = await getByIndex(STORES.TASKS, 'goalId', goal.id);
                for (const task of tasksToDelete) {
                    await remove(STORES.TASKS, task.id);
                }
                // Eliminar la meta
                await remove(STORES.GOALS, goal.id);
            }

            // Finalmente, eliminar el ciclo
            await remove(STORES.CYCLES, cycleId);

            alert(`"${itemName}" y todos sus elementos relacionados han sido eliminados.`);
            loadCycles(); // Recargar la lista de ciclos
            loadDashboardData(); // Actualizar dashboard
        } catch (error) {
            console.error('Error al eliminar ciclo y sus dependencias:', error);
            alert('Error al eliminar el ciclo. Consulta la consola para más detalles.');
        }
    };
    showConfirmModal(`¿Estás seguro de que quieres eliminar el ${itemType} "${itemName}"? Se eliminarán también todas las metas y tareas asociadas.`, confirmActionCallback);
}

/**
 * Carga los datos necesarios para la vista de Metas (selector de ciclos y metas del ciclo seleccionado).
 */
async function loadGoalsViewData() {
    try {
        const cycles = await getAll(STORES.CYCLES);
        renderCycleSelectForGoals(cycles, currentSelectedCycleId);

        // Si ya hay un ciclo seleccionado, cargar sus metas
        if (currentSelectedCycleId) {
            await loadGoalsForSelectedCycle(currentSelectedCycleId);
            DOMElements.addGoalBtn.classList.remove('hidden');
            DOMElements.noCycleSelectedMessage.classList.add('hidden');
        } else {
            DOMElements.goalsList.innerHTML = '<p class="no-items-message">No hay metas para este ciclo aún.</p>';
            DOMElements.addGoalBtn.classList.add('hidden');
            DOMElements.noCycleSelectedMessage.classList.remove('hidden');
        }
        DOMElements.goalFormContainer.classList.add('hidden'); // Asegurarse de que el formulario esté oculto
        resetGoalForm();
    } catch (error) {
        console.error('Error al cargar datos de la vista de metas:', error);
        alert('Error al cargar la vista de metas. Consulta la consola para más detalles.');
    }
}

/**
 * Maneja el cambio en el selector de ciclos en la vista de Metas.
 * @param {Event} event
 */
async function handleCycleSelectForGoalsChange(event) {
    currentSelectedCycleId = event.target.value ? parseInt(event.target.value) : null;
    if (currentSelectedCycleId) {
        await loadGoalsForSelectedCycle(currentSelectedCycleId);
        DOMElements.addGoalBtn.classList.remove('hidden');
        DOMElements.noCycleSelectedMessage.classList.add('hidden');
    } else {
        DOMElements.goalsList.innerHTML = '<p class="no-items-message">No hay metas para este ciclo aún.</p>';
        DOMElements.addGoalBtn.classList.add('hidden');
        DOMElements.noCycleSelectedMessage.classList.remove('hidden');
    }
    DOMElements.goalFormContainer.classList.add('hidden'); // Ocultar formulario al cambiar de ciclo
    resetGoalForm();
}

/**
 * Carga y renderiza las metas para un ciclo específico.
 * @param {number} cycleId - ID del ciclo.
 */
async function loadGoalsForSelectedCycle(cycleId) {
    try {
        const goals = await getByIndex(STORES.GOALS, 'cycleId', cycleId);
        const cycle = await get(STORES.CYCLES, cycleId); // Para obtener el nombre del ciclo
        const goalsWithTaskCount = [];

        // Para cada meta, contar sus tareas y añadir el nombre del ciclo
        for (const goal of goals) {
            const tasks = await getByIndex(STORES.TASKS, 'goalId', goal.id);
            goalsWithTaskCount.push({
                ...goal,
                tasksCount: tasks.length,
                cycleName: cycle ? cycle.name : 'Desconocido' // Añadir nombre del ciclo
            });
        }
        renderGoals(goalsWithTaskCount, editGoal, deleteGoal, manageTasksForGoal, updateGoalProgress);
    } catch (error) {
        console.error('Error al cargar metas para el ciclo:', error);
        alert('Error al cargar metas. Consulta la consola para más detalles.');
    }
}

/**
 * Navega a la vista de metas y selecciona el ciclo especificado.
 * @param {number} cycleId - ID del ciclo a seleccionar.
 */
function selectCycleAndShowGoals(cycleId) {
    currentSelectedCycleId = cycleId; // Establecer el ciclo actual
    DOMElements.navGoalsBtn.click(); // Simular clic en el botón de Metas para cambiar la vista
    // La función handleCycleSelectForGoalsChange será llamada por el evento 'change'
    // que se dispara cuando se asigna el valor al select en loadGoalsViewData()
    // Asegurarse de que el select se actualice y dispare el evento
    DOMElements.selectCycleForGoals.value = cycleId;
    const event = new Event('change');
    DOMElements.selectCycleForGoals.dispatchEvent(event);
}


/**
 * Maneja el envío del formulario de meta (crear/editar).
 * @param {Event} event
 */
async function handleGoalFormSubmit(event) {
    event.preventDefault();

    const id = DOMElements.goalIdInput.value ? parseInt(DOMElements.goalIdInput.value) : null;
    const cycleId = parseInt(DOMElements.goalCycleIdInput.value);
    const name = DOMElements.goalNameInput.value.trim();
    const description = DOMElements.goalDescriptionInput.value.trim();
    const target = DOMElements.goalTargetInput.value.trim();

    if (!name || !target || !cycleId) {
        alert('Por favor, completa todos los campos requeridos para la meta y selecciona un ciclo.');
        return;
    }

    try {
        if (id) {
            // Editar meta existente
            const existingGoal = await get(STORES.GOALS, id);
            if (!existingGoal) {
                alert('Meta no encontrada para actualizar.');
                return;
            }
            const updatedGoal = new Goal(cycleId, name, description, target, id);
            // Mantener propiedades originales
            updatedGoal.completed = existingGoal.completed;
            updatedGoal.progress = existingGoal.progress;
            updatedGoal.createdAt = existingGoal.createdAt;
            await update(STORES.GOALS, updatedGoal);
            alert('Meta actualizada con éxito!');
        } else {
            // Crear nueva meta
            const newGoal = new Goal(cycleId, name, description, target);
            await add(STORES.GOALS, newGoal);
            alert('Meta creada con éxito!');
        }
        DOMElements.goalFormContainer.classList.add('hidden');
        loadGoalsForSelectedCycle(cycleId); // Recargar la lista de metas
        loadDashboardData(); // Actualizar dashboard
    } catch (error) {
        console.error('Error al guardar meta:', error);
        alert('Error al guardar la meta. Consulta la consola para más detalles.');
    }
}

/**
 * Carga una meta en el formulario para edición.
 * @param {number} goalId - ID de la meta a editar.
 */
async function editGoal(goalId) {
    try {
        const goal = await get(STORES.GOALS, goalId);
        if (goal) {
            toggleForm(DOMElements.goalFormContainer, DOMElements.goalFormTitle, `Editar Meta: ${goal.name}`, goal, resetGoalForm);
        } else {
            alert('Meta no encontrada para edición.');
        }
    } catch (error) {
        console.error('Error al cargar meta para edición:', error);
        alert('Error al cargar meta para edición. Consulta la consola para más detalles.');
    }
}

/**
 * Elimina una meta y sus tareas asociadas.
 * @param {number} goalId - ID de la meta a eliminar.
 * @param {string} itemType - Tipo de ítem (para el mensaje de confirmación).
 * @param {string} itemName - Nombre del ítem (para el mensaje de confirmación).
 */
function deleteGoal(goalId, itemType, itemName) {
    confirmActionCallback = async () => {
        try {
            // Eliminar todas las tareas asociadas a esta meta
            const tasksToDelete = await getByIndex(STORES.TASKS, 'goalId', goalId);
            for (const task of tasksToDelete) {
                await remove(STORES.TASKS, task.id);
            }
            // Finalmente, eliminar la meta
            await remove(STORES.GOALS, goalId);
            alert(`"${itemName}" y sus tareas asociadas han sido eliminados.`);
            loadGoalsForSelectedCycle(currentSelectedCycleId); // Recargar la lista de metas
            loadDashboardData(); // Actualizar dashboard
        } catch (error) {
            console.error('Error al eliminar meta y tareas:', error);
            alert('Error al eliminar la meta. Consulta la consola para más detalles.');
        }
    };
    showConfirmModal(`¿Estás seguro de que quieres eliminar la ${itemType} "${itemName}"? Se eliminarán también todas las tareas asociadas.`, confirmActionCallback);
}

/**
 * Actualiza el progreso de una meta.
 * @param {number} goalId - ID de la meta.
 * @param {number} progressValue - Valor del progreso (0-100).
 */
async function updateGoalProgress(goalId, progressValue) {
    try {
        const goal = await get(STORES.GOALS, goalId);
        if (goal) {
            goal.progress = progressValue;
            await update(STORES.GOALS, goal);
            // No es necesario recargar la lista de metas completamente,
            // ya que el slider de progreso actualiza visualmente.
            // Solo actualizamos el dashboard si es necesario.
            loadDashboardData(); // Para que el progreso general del ciclo se actualice
        }
    } catch (error) {
        console.error('Error al actualizar progreso de meta:', error);
        alert('Error al actualizar progreso de meta. Consulta la consola para más detalles.');
    }
}

/**
 * Abre el modal de gestión de tareas para una meta.
 * @param {number} goalId - ID de la meta.
 * @param {string} goalName - Nombre de la meta.
 */
async function manageTasksForGoal(goalId, goalName) {
    showTaskModal(goalId, goalName);
    await loadTasksForGoal(goalId);
}

/**
 * Carga y renderiza las tareas para una meta específica en el modal.
 * @param {number} goalId - ID de la meta.
 */
async function loadTasksForGoal(goalId) {
    try {
        const tasks = await getByIndex(STORES.TASKS, 'goalId', goalId);
        renderTasks(tasks, toggleTaskComplete, deleteTask);
    } catch (error) {
        console.error('Error al cargar tareas:', error);
        alert('Error al cargar las tareas. Consulta la consola para más detalles.');
    }
}

/**
 * Maneja el envío del formulario de tarea (crear/editar).
 * @param {Event} event
 */
async function handleTaskFormSubmit(event) {
    event.preventDefault();

    const id = DOMElements.taskIdInput.value ? parseInt(DOMElements.taskIdInput.value) : null;
    const goalId = parseInt(DOMElements.modalGoalIdInput.value);
    const name = DOMElements.taskNameInput.value.trim();
    const dueDate = DOMElements.taskDueDateInput.value || null; // Puede ser opcional

    if (!name || !goalId) {
        alert('Por favor, completa el nombre de la tarea.');
        return;
    }

    try {
        if (id) {
            // Editar tarea existente
            const existingTask = await get(STORES.TASKS, id);
            if (!existingTask) {
                alert('Tarea no encontrada para actualizar.');
                return;
            }
            const updatedTask = new Task(goalId, name, dueDate, id);
            updatedTask.completed = existingTask.completed; // Mantener estado de completitud
            updatedTask.createdAt = existingTask.createdAt;
            await update(STORES.TASKS, updatedTask);
            alert('Tarea actualizada con éxito!');
        } else {
            // Crear nueva tarea
            const newTask = new Task(goalId, name, dueDate);
            await add(STORES.TASKS, newTask);
            alert('Tarea creada con éxito!');
        }
        DOMElements.taskFormContainer.classList.add('hidden');
        loadTasksForGoal(goalId); // Recargar la lista de tareas en el modal
        loadDashboardData(); // Actualizar dashboard
    } catch (error) {
        console.error('Error al guardar tarea:', error);
        alert('Error al guardar la tarea. Consulta la consola para más detalles.');
    }
}

/**
 * Marca o desmarca una tarea como completada.
 * @param {number} taskId - ID de la tarea.
 */
async function toggleTaskComplete(taskId) {
    try {
        const task = await get(STORES.TASKS, taskId);
        if (task) {
            task.completed = !task.completed;
            await update(STORES.TASKS, task);
            await loadTasksForGoal(task.goalId); // Recargar la lista de tareas
            loadDashboardData(); // Actualizar dashboard
        }
    } catch (error) {
        console.error('Error al cambiar estado de tarea:', error);
        alert('Error al cambiar estado de tarea. Consulta la consola para más detalles.');
    }
}

/**
 * Elimina una tarea.
 * @param {number} taskId - ID de la tarea a eliminar.
 * @param {string} itemType - Tipo de ítem (para el mensaje de confirmación).
 * @param {string} itemName - Nombre del ítem (para el mensaje de confirmación).
 */
function deleteTask(taskId, itemType, itemName) {
    confirmActionCallback = async () => {
        try {
            const task = await get(STORES.TASKS, taskId); // Necesitamos el goalId para recargar
            if (task) {
                await remove(STORES.TASKS, taskId);
                alert(`"${itemName}" ha sido eliminada.`);
                await loadTasksForGoal(task.goalId); // Recargar la lista de tareas en el modal
                loadDashboardData(); // Actualizar dashboard
            }
        } catch (error) {
            console.error('Error al eliminar tarea:', error);
            alert('Error al eliminar la tarea. Consulta la consola para más detalles.');
        }
    };
    showConfirmModal(`¿Estás seguro de que quieres eliminar la ${itemType} "${itemName}"?`, confirmActionCallback);
}

/**
 * Exporta todos los datos de la aplicación a un archivo JSON.
 */
async function exportData() {
    try {
        const allCycles = await getAll(STORES.CYCLES);
        const allGoals = await getAll(STORES.GOALS);
        const allTasks = await getAll(STORES.TASKS);

        const dataToExport = {
            cycles: allCycles,
            goals: allGoals,
            tasks: allTasks
        };

        const jsonString = JSON.stringify(dataToExport, null, 2); // Formato legible
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        const date = new Date().toISOString().split('T')[0];
        a.download = `mi-ano-12-semanas-backup-${date}.json`;
        document.body.appendChild(a); // Necesario para Firefox
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert('Datos exportados con éxito! Se ha descargado un archivo JSON.');
    } catch (error) {
        console.error('Error al exportar datos:', error);
        alert('Error al exportar datos. Consulta la consola para más detalles.');
    }
}

let importedFile = null; // Variable para almacenar el archivo seleccionado para importar

/**
 * Maneja la selección de un archivo JSON para importar.
 * @param {Event} event
 */
function handleImportFileChange(event) {
    const file = event.target.files[0];
    if (file) {
        if (file.type !== 'application/json') {
            alert('Por favor, selecciona un archivo JSON válido.');
            showImportFileSelection(null);
            return;
        }
        importedFile = file;
        showImportFileSelection(file);
    } else {
        importedFile = null;
        showImportFileSelection(null);
    }
}

/**
 * Confirma y realiza la importación de datos desde el archivo JSON seleccionado.
 */
function confirmImportData() {
    if (!importedFile) {
        alert('No hay archivo seleccionado para importar.');
        return;
    }

    showConfirmModal('¿Estás seguro de que quieres importar estos datos? ¡Esto sobrescribirá todos los datos existentes en la aplicación!', async () => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const data = JSON.parse(e.target.result);

                if (!data.cycles || !data.goals || !data.tasks) {
                    throw new Error('El archivo JSON no tiene la estructura de datos esperada (debe contener "cycles", "goals" y "tasks").');
                }

                // Limpiar todas las stores existentes antes de importar
                await clearAllStores();

                // Importar ciclos, asegurando que los IDs se mantengan para la relación
                for (const cycleData of data.cycles) {
                    await add(STORES.CYCLES, cycleData); // IndexedDB re-usará IDs si se le dan, o generará nuevos si no
                }
                // Importar metas
                for (const goalData of data.goals) {
                    await add(STORES.GOALS, goalData);
                }
                // Importar tareas
                for (const taskData of data.tasks) {
                    await add(STORES.TASKS, taskData);
                }

                alert('Datos importados con éxito! La aplicación se recargará.');
                location.reload(); // Recargar la página para asegurar que todos los datos se carguen correctamente
            } catch (error) {
                console.error('Error al importar datos:', error);
                alert(`Error al importar datos: ${error.message}. Asegúrate de que el archivo es válido.`);
            } finally {
                importedFile = null;
                hideConfirmModal();
                showImportFileSelection(null); // Resetear UI de importación
            }
        };
        reader.onerror = (e) => {
            console.error('Error al leer el archivo:', e);
            alert('Error al leer el archivo. Inténtalo de nuevo.');
            importedFile = null;
            hideConfirmModal();
            showImportFileSelection(null);
        };
        reader.readAsText(importedFile);
    });
}


export { initControllers };
7. js/app.js (El Punto de Entrada de la Aplicación)
Este archivo se encarga de inicializar la base de datos y los controladores cuando el DOM esté listo.

JavaScript

// js/app.js

import { openDB } from './db.js';
import { initControllers } from './controllers.js';

document.addEventListener('DOMContentLoaded', async () => {
    try {
        await openDB(); // Abrir la base de datos IndexedDB
        console.log('Base de datos inicializada correctamente.');
        initControllers(); // Inicializar todos los controladores de eventos
    } catch (error) {
        console.error('Fallo al inicializar la aplicación:', error);
        alert('La aplicación no pudo iniciarse correctamente. Por favor, asegúrate de que tu navegador soporta IndexedDB y consulta la consola para más detalles.');
    }
});

8. assets/ (Imágenes de Ejemplo)
Crea la carpeta assets y guarda allí algunas imágenes PNG con nombres como:

logo.png (para el logo principal)

icon_cycle.png (icono pequeño para ciclos)

icon_goal.png (icono pequeño para metas)

icon_task.png (icono pequeño para tareas)

Puedes usar cualquier imagen que te guste, solo asegúrate de que los nombres de archivo coincidan con los que están en el código. Si no tienes iconos específicos, puedes simplemente eliminarlos de las plantillas HTML o reemplazarlos con <span> para texto, pero los he incluido para mejorar la UX. Aquí te dejo algunos enlaces a iconos gratuitos que podrías usar:

Flaticon

The Noun Project

Font Awesome (si decides integrar una librería de iconos en lugar de imágenes, lo que simplificaría la gestión, pero requeriría un CDN o descargar los archivos). Para mantenerlo 100% offline, descarga los PNGs.

Cómo Probar la Aplicación en Android (Localmente)
Copia la Carpeta: Copia toda la carpeta mi-ano-12-semanas a tu teléfono Android. Puedes colocarla en la raíz de tu almacenamiento interno o en cualquier carpeta accesible.

Inicia Simple HTTP Server: Abre la aplicación "Simple HTTP Server" en tu Android.

Configura el Servidor:

Navega y selecciona la carpeta mi-ano-12-semanas como el directorio raíz que el servidor debe servir.

Asegúrate de que el puerto esté configurado (ej. 8000 o 8080).

Inicia el servidor. La aplicación te dará una dirección como http://localhost:8000 o http://[tu_ip_local]:8000.

Abre en el Navegador: Abre el navegador web de tu Android (Chrome, Firefox, etc.) y navega a la dirección que te dio Simple HTTP Server (ej., http://localhost:8000).

¡Tu aplicación "Mi Año de 12 Semanas" debería cargarse y ser completamente funcional de forma local!

Verificación y Consideraciones Finales
Funcionamiento CRUD:

Ciclos: Podrás crear, editar y eliminar ciclos. Al eliminar un ciclo, se confirmará la eliminación de todas sus metas y tareas asociadas (comportamiento en cascada).

Metas: Podrás seleccionar un ciclo y luego crear, editar, eliminar metas. El slider de progreso de metas funciona.

Tareas: Desde las metas, podrás abrir un modal para crear, marcar como completado/deshacer y eliminar tareas.

Persistencia de Datos: Todos los datos (ciclos, metas, tareas, progreso) se guardan en IndexedDB y persistirán entre cierres de la aplicación o del navegador.

Portabilidad: La funcionalidad de "Exportar/Importar Datos" te permite guardar un archivo JSON con toda la base de datos. Este archivo puede ser movido a otro dispositivo y luego importado, sobrescribiendo los datos existentes para transferir tu progreso.

Responsividad: Se ha aplicado un diseño responsivo básico (@media queries, Flexbox) para que la interfaz se adapte bien tanto a pantallas de teléfonos móviles como a tabletas o PCs de escritorio. Los elementos se reorganizan y los botones se expanden para mejorar la usabilidad en pantallas pequeñas.

Manejo de Errores: Se han incluido bloques try-catch y alert() básicos para informar al usuario sobre errores, aunque para una aplicación más compleja se usarían notificaciones más sofisticadas.

JavaScript Nativo: No se utilizan frameworks ni librerías externas, lo que garantiza una huella de archivo mínima y máxima compatibilidad con el entorno local y Android.

Estilo de Código: Se usa un estilo de programación modular con importaciones/exportaciones de ES6 para separar Modelos, Vistas y Controladores, mejorando la organización y mantenibilidad del código.

Espero que este proyecto cumpla con todas tus expectativas y sea una herramienta útil para tu "Año de 12 Semanas". ¡Si tienes alguna pregunta o necesitas ajustar algo, no dudes en consultarme!